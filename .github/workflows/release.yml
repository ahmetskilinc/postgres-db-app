name: Build and Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (example: v0.2.0)"
        required: true
        type: string
      release_name:
        description: "Release title (optional)"
        required: false
        type: string
      release_notes:
        description: "Extra notes appended to generated notes (optional)"
        required: false
        type: string

permissions:
  contents: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.vars.outputs.tag }}
      version: ${{ steps.vars.outputs.version }}
      release_name: ${{ steps.vars.outputs.release_name }}
      release_notes: ${{ steps.vars.outputs.release_notes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Resolve release values
        id: vars
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ inputs.tag }}"
            NAME="${{ inputs.release_name }}"
            NOTES="${{ inputs.release_notes }}"
            if [[ -z "$NAME" ]]; then
              NAME="Table ${TAG}"
            fi
          else
            TAG="${GITHUB_REF_NAME}"
            NAME="Table ${TAG}"
            NOTES=""
          fi
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "release_name=$NAME" >> "$GITHUB_OUTPUT"
          {
            echo "release_notes<<EOF"
            echo "$NOTES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Patch package version for manual run
        if: github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          VERSION="${{ steps.vars.outputs.version }}"
          bun -e '
          const fs = require("fs");
          const version = process.argv[1];
          const pkgPath = "package.json";
          const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
          pkg.version = version;
          fs.writeFileSync(pkgPath, `${JSON.stringify(pkg, null, 2)}\n`);
          ' "$VERSION"
          if git diff --quiet -- package.json; then
            echo "No version file changes detected."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add package.json
          if [[ -f package-lock.json ]]; then
            git add package-lock.json
          fi
          git commit -m "chore(release): bump version to $VERSION"
          git push origin HEAD

      - name: Verify tag matches package version on tag push
        if: github.event_name == 'push'
        shell: bash
        run: |
          VERSION_FROM_TAG="${{ steps.vars.outputs.version }}"
          VERSION_FROM_PACKAGE="$(bun -e 'const fs = require("fs"); const pkg = JSON.parse(fs.readFileSync("package.json", "utf8")); process.stdout.write(pkg.version);')"
          if [[ "$VERSION_FROM_TAG" != "$VERSION_FROM_PACKAGE" ]]; then
            echo "Tag version ($VERSION_FROM_TAG) does not match package.json version ($VERSION_FROM_PACKAGE)."
            exit 1
          fi

      - name: Create tag for manual run
        if: github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          TAG="${{ steps.vars.outputs.tag }}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag exists locally: $TAG"
            exit 0
          fi
          if git ls-remote --exit-code --tags origin "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Tag exists on origin: $TAG"
            exit 0
          fi
          git tag "$TAG"
          git push origin "$TAG"

  build:
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: refs/tags/${{ needs.prepare.outputs.tag }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build app bundles
        run: bun run build

      - name: Check mac signing secrets
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          MISSING=0
          for KEY in CSC_LINK CSC_KEY_PASSWORD APPLE_ID APPLE_APP_SPECIFIC_PASSWORD APPLE_TEAM_ID; do
            if [[ -z "${!KEY}" ]]; then
              echo "Missing required secret: $KEY"
              MISSING=1
            fi
          done
          if [[ "$MISSING" -ne 0 ]]; then
            exit 1
          fi
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Build macOS installer
        if: matrix.os == 'macos-latest'
        run: bunx electron-builder --mac dmg --publish never
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          CSC_IDENTITY_AUTO_DISCOVERY: "true"

      - name: Verify mac app signature and notarization
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          shopt -s nullglob
          APPS=(dist/mac*/Table.app)
          DMGS=(dist/*.dmg)
          if [[ ${#APPS[@]} -eq 0 ]]; then
            echo "No built .app found in dist/mac*/Table.app"
            exit 1
          fi
          if [[ ${#DMGS[@]} -eq 0 ]]; then
            echo "No dmg found in dist/*.dmg"
            exit 1
          fi
          APP_PATH="${APPS[0]}"
          DMG_PATH="${DMGS[0]}"
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"
          spctl -a -vv --type exec "$APP_PATH"
          xcrun stapler validate "$DMG_PATH"

      - name: Build Windows installer
        if: matrix.os == 'windows-latest'
        run: bunx electron-builder --win nsis --publish never

      - name: Build Linux installer
        if: matrix.os == 'ubuntu-latest'
        run: bunx electron-builder --linux AppImage --publish never

      - name: Upload packaged artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.os }}
          if-no-files-found: warn
          path: |
            dist/*.dmg
            dist/*.zip
            dist/*.exe
            dist/*.nsis.7z
            dist/*.AppImage
            dist/*.blockmap
            dist/latest*.yml
            dist/latest*.yaml
            dist/*.yml
            dist/*.yaml

  release:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          path: release-assets
          merge-multiple: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: ${{ needs.prepare.outputs.release_name }}
          generate_release_notes: true
          append_body: true
          body: ${{ needs.prepare.outputs.release_notes }}
          files: release-assets/**
